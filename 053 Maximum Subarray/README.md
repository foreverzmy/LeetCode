# Maximum Subarray

## Question

### leetcode

[Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)

### 中文描述：

在一个数组中找到连续的子数组（至少包含一个数字），使子数组的总和最大。

### 例子

```
given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
```

## Answer

### 思路1

遍历数组，对于每一个数字，如果之前的数字之和加这个数字与这个数字比大小，如果这个数字自己就比之前的数字之和加这个数字大的话，那么说明不需要再继续加了，直接从这个数字，开始继续，因为它自己已经比之前的sum都大了；

反过来，如果之前的数字之和加这个数字大于这个数字，就继续加下，并将结果与前面所有和的最大值比较，将大的保存到最大值里。

### 思路2

先考虑特殊情况：
1. 如果数组没有值，返回0；
2. 如果数组长度为1，返回第一个值。

然后考虑正常情况：

要找到一个数组中最大连续子串的和，这里很重要的一个点就是**连续**；假设这个最大和数的连续子串为`[i...j]`，那么：

`SUM[j] = nums[j] + SUM[j - 1]; (j - 1 >= i)`

举个简单的例子：

有数组`[..., -2, 1, 3, 4]`，在遍历过程中，当我们遍历到`-2`的时候，得到的值有两种：
1. 小于0：如果出现了小于0的情况，我们应该将和数重置为0，作为`SUM[j - 1]`，这里的做法是为了**消除连续**，也就是将后续子串作为一个新的`[i...j]`进行计算；
2. 2.大于等于0：将新的和数作为`SUM[j - 1]`；

> 之所以把情况1作为下一个子串的起点，是因为，既然n个数加上一个-C的值是一个较大的值，那么排除掉-C之后，这个值不就是一个更大的值么，所以如果出现和数小于0，那么它的下一个数完全可以作为下一个连续子串的开始；也就是说两个子串中，只有开头为正数的一个才是最大子串，
> 
> Eg: `[-1, 2, 3, 4, ...]`和`[1, 2, 3, 4, ...]`

### 代码

[思路1](./main_01.js)
[思路2](./main_02.js)
