# Reverse Linked List

> 收录在LeetCode字节跳动题库中

## Question

### leetcode

[Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list/)

### 中文描述：

反转一个单链表。

### 例子

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

### 进阶要求

你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

## Answer

### 迭代法

关键在于需要将当前节点塞到保存的翻转链表的最前端去（这个好做，只需要将当前节点的下一个节点指向上一个翻转链表）；

**以上做法会丢失下一个节点的信息，但是为了能够让链表继续遍历，所以就需要在开始上面操作前保存下个节点的信息**

### 递归

递归会比较难理解，关键在于，递归到返回阶段的时候，前面的递归函数已经保存了过程中的每一个节点的**指针**信息；
比如，以`[1, 2, 3]`为例：递归只有到3才开始正式运算（也就是返回），这时候其实前面已经保存了`ƒ(2)`和`ƒ(1)`；
即`ƒ(<1>ƒ(<2>ƒ(3)))`，**所以，当我们遍历到链表末尾回头遍历`2`的时候，我们只需要关注`2`应该与它下一层的返回，**
**即`3`之间的关系：2 -> next(3) -> next = 2; 2 -> next(3) = ∅；至于为什么，可以看下面的示意**

```
---------------------------------------------------------------------------------
current list               || result
---------------------------------------------------------------------------------
1. 1 -> 2 -> 3 -> 4 -> 5 | || (1 -> 2 -> 2) => r(5 -> 4 -> 3 -> 2 -> 1), 1 -> ∅ ↑
2. 2 -> 3 -> 4 -> 5      | || (2 -> 3 -> 2) => r(5 -> 4 -> 3 -> 2), 2 -> ∅      |
3. 3 -> 4 -> 5           | || (3 -> 4 -> 3) => r(5 -> 4 -> 3), 3 -> ∅           |
4. 4 -> 5                | || (4 -> 5 -> 4) => r(5 -> 4), 4 -> ∅                |
5. 5                     ↓ || r(5)                                              |
```

如上表所示，我们最终拿到的就是`r`的结果；

在这套流程中，需要注意的点就是，每次翻转完成之后，都需要将当前节点的下一个节点指向空；以编号`5 -> 3`为例,
如果在`4`中没有清空`[4]`的下一节点，那么在`3`中就会因为`r`就会变成`r(5 -> 4 -> 5 -> 4 ...)`而报错了。

### 代码

[JS](./main_01.js)
[JS](./main_02.js)
